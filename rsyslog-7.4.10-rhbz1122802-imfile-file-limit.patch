From 0c1495da2ec2cd8b07ffaf36854d2ad81d4af67c Mon Sep 17 00:00:00 2001
From: Tomas Heinrich <theinric@redhat.com>
Date: Wed, 9 Dec 2015 15:48:16 +0100
Subject: [PATCH] imfile: permit to monitor an unlimited number of files

Adapted from

commit 29ca3f2f95ffe02811499b113f50a19eb81e3b29
Author: Rainer Gerhards <rgerhards@adiscon.com>
Date:   Mon Oct 14 15:12:05 2013 +0200
---
 plugins/imfile/imfile.c | 74 ++++++++++++++++++++++++++++++++-----------------
 1 file changed, 48 insertions(+), 26 deletions(-)

diff --git a/plugins/imfile/imfile.c b/plugins/imfile/imfile.c
index 9c824c1..039b0e7 100644
--- a/plugins/imfile/imfile.c
+++ b/plugins/imfile/imfile.c
@@ -70,6 +70,11 @@ static int bLegacyCnfModGlobalsPermitted;/* are legacy module-global config para
 #define NUM_MULTISUB 1024 /* default max number of submits */
 #define DFLT_PollInterval 10
 
+#define INIT_FILE_TAB_SIZE 4 /* default file table size - is extended as needed, use 2^x value */
+
+/* this structure is used in pure polling mode as well one of the support
+ * structures for inotify.
+ */
 typedef struct fileInfo_s {
 	uchar *pszFileName;
 	uchar *pszTag;
@@ -132,8 +137,8 @@ static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current l
 static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current load process */
 
 static int iFilPtr = 0;		/* number of files to be monitored; pointer to next free spot during config */
-#define MAX_INPUT_FILES 100
-static fileInfo_t files[MAX_INPUT_FILES];
+static fileInfo_t *files = NULL;
+static int currMaxFiles;
 
 static prop_t *pInputName = NULL;	/* there is only one global inputName for all messages generated by this input */
 
@@ -405,33 +410,43 @@ static inline rsRetVal
 addListner(instanceConf_t *inst)
 {
 	DEFiRet;
+	int newMax;
+	fileInfo_t *newFileTab;
 	fileInfo_t *pThis;
 
-	if(iFilPtr < MAX_INPUT_FILES) {
-		pThis = &files[iFilPtr];
-		//TODO: optimize, save strdup?
-		pThis->pszFileName = (uchar*) strdup((char*) inst->pszFileName);
-		pThis->pszTag = (uchar*) strdup((char*) inst->pszTag);
-		pThis->lenTag = ustrlen(pThis->pszTag);
-		pThis->pszStateFile = (uchar*) strdup((char*) inst->pszStateFile);
-
-		CHKiRet(ratelimitNew(&pThis->ratelimiter, "imfile", (char*)inst->pszFileName));
-		CHKmalloc(pThis->multiSub.ppMsgs = MALLOC(inst->nMultiSub * sizeof(msg_t*)));
-		pThis->multiSub.maxElem = inst->nMultiSub;
-		pThis->multiSub.nElem = 0;
-		pThis->iSeverity = inst->iSeverity;
-		pThis->iFacility = inst->iFacility;
-		pThis->maxLinesAtOnce = inst->maxLinesAtOnce;
-		pThis->iPersistStateInterval = inst->iPersistStateInterval;
-		pThis->readMode = inst->readMode;
-		pThis->pRuleset = inst->pBindRuleset;
-		pThis->nRecords = 0;
-	} else {
-		errmsg.LogError(0, RS_RET_OUT_OF_DESRIPTORS,
-				"Too many file monitors configured - ignoring %s",
-				inst->pszFileName);
-		ABORT_FINALIZE(RS_RET_OUT_OF_DESRIPTORS);
+	if(iFilPtr == currMaxFiles) {
+		newMax = 2 * currMaxFiles;
+		newFileTab = realloc(files, newMax * sizeof(fileInfo_t));
+		if(newFileTab == NULL) {
+			errmsg.LogError(0, RS_RET_OUT_OF_MEMORY,
+					"cannot alloc memory to monitor file '%s' - ignoring",
+					inst->pszFileName);
+			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
+		}
+		files = newFileTab;
+		currMaxFiles = newMax;
+		DBGPRINTF("imfile: increased file table to %d entries\n", currMaxFiles);
 	}
+
+	/* if we reach this point, there is space in the file table for the new entry */
+	pThis = &files[iFilPtr];
+	pThis->pszFileName = (uchar*) strdup((char*) inst->pszFileName);
+	pThis->pszTag = (uchar*) strdup((char*) inst->pszTag);
+	pThis->lenTag = ustrlen(pThis->pszTag);
+	pThis->pszStateFile = (uchar*) strdup((char*) inst->pszStateFile);
+
+	CHKiRet(ratelimitNew(&pThis->ratelimiter, "imfile", (char*)inst->pszFileName));
+	CHKmalloc(pThis->multiSub.ppMsgs = MALLOC(inst->nMultiSub * sizeof(msg_t*)));
+	pThis->multiSub.maxElem = inst->nMultiSub;
+	pThis->multiSub.nElem = 0;
+	pThis->iSeverity = inst->iSeverity;
+	pThis->iFacility = inst->iFacility;
+	pThis->maxLinesAtOnce = inst->maxLinesAtOnce;
+	pThis->iPersistStateInterval = inst->iPersistStateInterval;
+	pThis->readMode = inst->readMode;
+	pThis->pRuleset = inst->pBindRuleset;
+	pThis->nRecords = 0;
+	pThis->pStrm = NULL;
 	++iFilPtr;	/* we got a new file to monitor */
 
 	resetConfigVariables(NULL, NULL); /* values are both dummies */
@@ -591,9 +606,15 @@ BEGINactivateCnf
 	instanceConf_t *inst;
 CODESTARTactivateCnf
 	runModConf = pModConf;
+	free(files); /* clear any previous instance */
+	CHKmalloc(files = (fileInfo_t*) malloc(sizeof(fileInfo_t) * INIT_FILE_TAB_SIZE));
+	currMaxFiles = INIT_FILE_TAB_SIZE;
+	iFilPtr = 0;
+
 	for(inst = runModConf->root ; inst != NULL ; inst = inst->next) {
 		addListner(inst);
 	}
+
 	/* if we could not set up any listeners, there is no point in running... */
 	if(iFilPtr == 0) {
 		errmsg.LogError(0, NO_ERRCODE, "imfile: no file monitors could be started, "
@@ -616,6 +637,7 @@ CODESTARTfreeCnf
 		inst = inst->next;
 		free(del);
 	}
+	free(files);
 ENDfreeCnf
 
 
-- 
1.9.3

